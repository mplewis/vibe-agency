#!/usr/bin/env python3
"""
VIBE-CLI - Agency OS Command Line Interface
============================================

This is the "Flie√üband" (conveyor belt) that connects Claude Code (the "Brain")
to the orchestrator (the "Arm").

Architecture (MVP - DELEGATION ONLY):
- Launches core_orchestrator.py in delegated mode
- Monitors STDOUT for INTELLIGENCE_REQUESTs
- Delegates prompts to Claude Code operator (via STDOUT/STDIN)
- Receives responses from Claude Code and forwards to orchestrator

Version: 1.0 (Delegation Mode - No Direct API Calls)
"""

# ============================================================================
# LAYER 2: UV ENVIRONMENT CHECK (Fail Fast with Guidance)
# ============================================================================
import sys
from pathlib import Path

def _ensure_uv_environment():
    """
    Ensure UV environment is set up (Layer 2 of 4-layer defense).

    Post-UV migration strategy:
    - Instead of auto-installing with pip (conflicts with uv.lock),
      check if .venv exists and guide users to proper setup.
    - This prevents pip/uv mixing and maintains deterministic builds.
    - Users who follow Layer 1 (devcontainer) or Layer 3 (setup.sh)
      never hit this check.

    Layer 2 catches users who:
    - Skip setup entirely
    - Run vibe-cli directly without proper environment

    Why not auto-install?
    - pip install conflicts with uv.lock (non-deterministic)
    - uv sync requires uv command (may not be available)
    - Better to guide users to canonical setup: make install

    Related: DEFENSE_VALIDATION_REPORT.md, MIGRATION_NOTES.md
    """
    repo_root = Path(__file__).parent
    venv_path = repo_root / ".venv"
    lock_path = repo_root / "uv.lock"

    # Check if UV environment exists
    if not venv_path.exists():
        print("‚ùå Error: UV environment not found", file=sys.stderr)
        print("", file=sys.stderr)
        print("It looks like dependencies aren't installed yet.", file=sys.stderr)
        print("", file=sys.stderr)
        print("Please run ONE of these commands:", file=sys.stderr)
        print("  make install          # Recommended (uses Makefile)", file=sys.stderr)
        print("  ./setup.sh            # Alternative (uses setup script)", file=sys.stderr)
        print("  uv sync --all-extras  # Direct (if uv is installed)", file=sys.stderr)
        print("", file=sys.stderr)
        print("This will create a .venv/ directory with all dependencies", file=sys.stderr)
        print("from the locked versions in uv.lock (deterministic builds).", file=sys.stderr)
        print("", file=sys.stderr)
        print("Why this error?", file=sys.stderr)
        print("  vibe-agency uses UV for dependency management (10-15x faster than pip).", file=sys.stderr)
        print("  Dependencies are locked in uv.lock for reproducibility.", file=sys.stderr)
        print("  See: MIGRATION_NOTES.md for more info.", file=sys.stderr)
        sys.exit(1)

    # Check if we're running in the UV environment
    # Note: Not strictly necessary (imports will fail if wrong env)
    # but provides better error message
    if not sys.prefix == str(venv_path):
        # Running outside .venv - might be manual activation or system Python
        # Don't fail hard, but warn (imports will fail if truly wrong)
        import os
        if not os.getenv("VIRTUAL_ENV"):  # Not in any venv
            print("‚ö†Ô∏è  Warning: Not running in UV environment", file=sys.stderr)
            print("", file=sys.stderr)
            print("Tip: Use 'uv run' to ensure correct environment:", file=sys.stderr)
            print("  uv run ./vibe-cli run <project-id>", file=sys.stderr)
            print("", file=sys.stderr)
            # Don't exit - let imports fail naturally if deps are wrong

# Execute environment check BEFORE any other imports
_ensure_uv_environment()

# ============================================================================
# IMPORTS (After Dependency Check)
# ============================================================================
import os
import json
import logging
import subprocess
import yaml
from pathlib import Path
from typing import Optional, Dict, Any, List

logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)


class VibeCLI:
    """
    Main CLI class that manages the orchestrator <-> Claude Code handoff.
    """

    def __init__(self, repo_root: Path):
        """
        Initialize vibe-cli.

        Args:
            repo_root: Root of vibe-agency repo

        Note: MVP uses DELEGATION ONLY mode.
              vibe-cli acts as a bridge between Claude Code (operator) and orchestrator.
              No direct API calls - intelligence is delegated to Claude Code operator.
        """
        self.repo_root = Path(repo_root)

        # Orchestrator path
        self.orchestrator_path = self.repo_root / "agency_os" / "00_system" / "orchestrator" / "core_orchestrator.py"

        if not self.orchestrator_path.exists():
            raise FileNotFoundError(f"Orchestrator not found: {self.orchestrator_path}")

        # Tool definitions path (GAD-003)
        self.tool_definitions_path = self.repo_root / "agency_os" / "00_system" / "orchestrator" / "tools" / "tool_definitions.yaml"

        # Tool executor path (for local tool execution)
        self.tool_executor_path = self.repo_root / "agency_os" / "00_system" / "orchestrator" / "tools"

    def run_project(self, project_id: str, mode: str = "delegated") -> None:
        """
        Run SDLC for a project with Claude Code integration.

        Args:
            project_id: Project ID
            mode: Execution mode (delegated or autonomous)
        """
        logger.info(f"üöÄ Starting Agency OS for project: {project_id}")
        logger.info(f"   Execution mode: {mode}")
        logger.info(f"   Repository: {self.repo_root}")

        if mode == "delegated":
            self._run_delegated(project_id)
        elif mode == "autonomous":
            self._run_autonomous(project_id)
        else:
            raise ValueError(f"Invalid mode: {mode}")

    def _run_delegated(self, project_id: str) -> None:
        """
        Run orchestrator in delegated mode with STDIN/STDOUT handoff.

        This method:
        1. Launches orchestrator as subprocess
        2. Monitors STDOUT for INTELLIGENCE_REQUESTs
        3. Delegates prompts to Claude Code operator
        4. Sends responses back via STDIN
        """
        logger.info("üîó Launching orchestrator in delegated mode...")

        # Launch orchestrator
        cmd = [
            sys.executable,
            str(self.orchestrator_path),
            str(self.repo_root),
            project_id,
            "--mode=delegated"
        ]

        logger.info(f"   Command: {' '.join(cmd)}")

        # Start process with pipes
        process = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1  # Line buffered
        )

        logger.info("‚úÖ Orchestrator launched (PID: {})".format(process.pid))

        # Monitor process output
        self._monitor_orchestrator(process)

    def _monitor_orchestrator(self, process: subprocess.Popen) -> None:
        """
        Monitor orchestrator STDOUT/STDERR and handle intelligence requests.

        Args:
            process: Orchestrator subprocess
        """
        intelligence_request_buffer = []
        capturing_request = False

        try:
            while True:
                # Read from STDOUT
                line = process.stdout.readline()

                if not line:
                    # Process finished
                    break

                # Check for intelligence request markers
                if "---INTELLIGENCE_REQUEST_START---" in line:
                    capturing_request = True
                    intelligence_request_buffer = []
                    logger.info("üì© Intelligence request detected...")
                    continue

                if "---INTELLIGENCE_REQUEST_END---" in line:
                    capturing_request = False
                    # Parse and handle request
                    request_json = ''.join(intelligence_request_buffer)
                    self._handle_intelligence_request(request_json, process)
                    continue

                if capturing_request:
                    intelligence_request_buffer.append(line)
                else:
                    # Regular output - print to console
                    print(line, end='')

                # Also check stderr for log messages
                # (non-blocking read would be better, but this works for now)

        except KeyboardInterrupt:
            logger.info("\n‚è∏Ô∏è  Interrupted by user")
            process.terminate()

        except Exception as e:
            logger.error(f"‚ùå Error monitoring orchestrator: {e}")
            process.terminate()
            raise

        finally:
            # Wait for process to finish
            return_code = process.wait()
            if return_code == 0:
                logger.info("‚úÖ Orchestrator finished successfully")
            else:
                logger.error(f"‚ùå Orchestrator failed with code {return_code}")

    def _handle_intelligence_request(self, request_json: str, process: subprocess.Popen) -> None:
        """
        Handle an intelligence request from orchestrator.

        Args:
            request_json: JSON string of intelligence request
            process: Orchestrator subprocess
        """
        try:
            # Parse request
            request = json.loads(request_json)

            agent = request.get('agent')
            task_id = request.get('task_id')
            prompt = request.get('prompt')
            context = request.get('context', {})

            logger.info(f"ü§ñ Intelligence Request:")
            logger.info(f"   Agent: {agent}")
            logger.info(f"   Task: {task_id}")
            logger.info(f"   Context: {context}")
            logger.info(f"   Prompt length: {len(prompt)} chars")

            # Delegate to Claude Code operator (MVP - DELEGATION ONLY)
            logger.info(f"‚öôÔ∏è  Delegating prompt to Claude Code operator...")
            result = self._delegate_to_operator(prompt, agent, task_id)

            # Build response
            response = {
                "type": "INTELLIGENCE_RESPONSE",
                "agent": agent,
                "task_id": task_id,
                "result": result,
                "metadata": {
                    "executor": "vibe-cli",
                    "model": "claude-3-5-sonnet-20241022"
                }
            }

            # Send response to orchestrator via STDIN
            response_json = json.dumps(response)
            logger.info(f"üì§ Sending intelligence response...")
            process.stdin.write(response_json + "\n")
            process.stdin.flush()
            logger.info(f"‚úÖ Intelligence response sent")

        except Exception as e:
            logger.error(f"‚ùå Failed to handle intelligence request: {e}")
            # Send error response
            error_response = {
                "type": "INTELLIGENCE_RESPONSE",
                "result": {"error": str(e)},
                "metadata": {"error": True}
            }
            process.stdin.write(json.dumps(error_response) + "\n")
            process.stdin.flush()

    def _load_tools_for_agent(self, agent: str) -> List[Dict[str, Any]]:
        """
        Load tool definitions for a specific agent.

        Args:
            agent: Agent name (e.g., "MARKET_RESEARCHER")

        Returns:
            List of Anthropic tool schemas
        """
        # Map agent names to their composition files
        agent_paths = {
            "MARKET_RESEARCHER": "agency_os/01_planning_framework/agents/research/MARKET_RESEARCHER/_composition.yaml",
            "TECH_RESEARCHER": "agency_os/01_planning_framework/agents/research/TECH_RESEARCHER/_composition.yaml",
            "FACT_VALIDATOR": "agency_os/01_planning_framework/agents/research/FACT_VALIDATOR/_composition.yaml",
            "USER_RESEARCHER": "agency_os/01_planning_framework/agents/research/USER_RESEARCHER/_composition.yaml",
        }

        # Check if agent has tools
        if agent not in agent_paths:
            logger.debug(f"Agent {agent} not in tool-enabled agents list, returning empty tools")
            return []

        # Load agent composition
        composition_path = self.repo_root / agent_paths[agent]
        if not composition_path.exists():
            logger.warning(f"Composition file not found: {composition_path}")
            return []

        with open(composition_path, 'r') as f:
            composition = yaml.safe_load(f)

        # Extract tool names
        tool_names = composition.get('tools', [])
        if not tool_names:
            logger.debug(f"Agent {agent} has no tools configured")
            return []

        # Load tool definitions
        if not self.tool_definitions_path.exists():
            logger.warning(f"Tool definitions not found: {self.tool_definitions_path}")
            return []

        with open(self.tool_definitions_path, 'r') as f:
            tool_definitions = yaml.safe_load(f)

        # Convert to Anthropic schema
        tools = []
        for tool_name in tool_names:
            if tool_name in tool_definitions.get('tools', {}):
                tool_def = tool_definitions['tools'][tool_name]
                anthropic_tool = self._convert_yaml_to_anthropic_schema(tool_name, tool_def)
                tools.append(anthropic_tool)
            else:
                logger.warning(f"Tool {tool_name} not found in tool_definitions.yaml")

        logger.info(f"Loaded {len(tools)} tools for agent {agent}: {[t['name'] for t in tools]}")
        return tools

    def _convert_yaml_to_anthropic_schema(self, tool_name: str, tool_def: Dict[str, Any]) -> Dict[str, Any]:
        """
        Convert YAML tool definition to Anthropic's JSON tool schema.

        Args:
            tool_name: Tool name (e.g., "google_search")
            tool_def: YAML tool definition

        Returns:
            Anthropic tool schema (JSON)
        """
        # Build input schema
        properties = {}
        required = []

        for param_name, param_def in tool_def.get('parameters', {}).items():
            properties[param_name] = {
                "type": param_def.get('type', 'string'),
                "description": param_def.get('description', '')
            }

            # Add default if specified
            if 'default' in param_def:
                properties[param_name]['default'] = param_def['default']

            # Track required parameters
            if param_def.get('required', False):
                required.append(param_name)

        # Return Anthropic tool schema
        return {
            "name": tool_name,
            "description": tool_def.get('description', ''),
            "input_schema": {
                "type": "object",
                "properties": properties,
                "required": required
            }
        }

    def _execute_tools(self, tool_use_blocks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Execute tool calls locally using tool_executor.py.

        Args:
            tool_use_blocks: List of tool_use content blocks from Anthropic API

        Returns:
            List of tool results
        """
        # Import tool executor (lazy import to avoid circular dependencies)
        sys.path.insert(0, str(self.tool_executor_path))
        try:
            from tool_executor import ToolExecutor
        except ImportError:
            logger.error("Failed to import tool_executor - tool execution disabled")
            return [{"error": "Tool executor not available"}]

        # Initialize tool executor
        executor = ToolExecutor()

        # Execute each tool
        results = []
        for tool_use in tool_use_blocks:
            if tool_use.get('type') != 'tool_use':
                continue

            tool_name = tool_use.get('name')
            tool_input = tool_use.get('input', {})
            tool_use_id = tool_use.get('id')

            logger.info(f"Executing tool: {tool_name} with input: {tool_input}")

            try:
                # Execute tool
                result = executor.execute_tool(tool_name, tool_input)
                results.append({
                    "type": "tool_result",
                    "tool_use_id": tool_use_id,
                    "content": json.dumps(result)
                })
                logger.info(f"Tool {tool_name} executed successfully")

            except Exception as e:
                logger.error(f"Tool {tool_name} execution failed: {e}")
                results.append({
                    "type": "tool_result",
                    "tool_use_id": tool_use_id,
                    "content": json.dumps({"error": str(e)}),
                    "is_error": True
                })

        return results

    def _delegate_to_operator(self, prompt: str, agent: str, task_id: str) -> Dict[str, Any]:
        """
        Delegate prompt execution to Claude Code operator (MVP - DELEGATION ONLY).

        This method DOES NOT call Anthropic API directly.
        Instead, it delegates to Claude Code operator via structured output.

        Architecture:
        1. Print delegation request to STDOUT (JSON)
        2. Claude Code operator reads request
        3. Claude Code calls Anthropic API
        4. Claude Code sends response via STDIN
        5. Return parsed response

        Args:
            prompt: Prompt text
            agent: Agent name
            task_id: Task ID

        Returns:
            Parsed response from Claude Code operator

        Note: This is the MVP architecture (DELEGATION ONLY).
              Standalone mode (direct API calls) is deferred to v1.1.
              See: docs/architecture/EXECUTION_MODE_STRATEGY.md
        """
        from datetime import datetime

        # Build delegation request
        delegation_request = {
            "type": "INTELLIGENCE_DELEGATION",
            "agent": agent,
            "task_id": task_id,
            "prompt": prompt,
            "timestamp": datetime.now().isoformat(),
            "metadata": {
                "delegator": "vibe-cli",
                "mode": "delegation_only"
            }
        }

        # Print delegation request to STDOUT (Claude Code reads this)
        logger.info("üì§ Delegating intelligence request to Claude Code operator...")
        print("\n---DELEGATION_REQUEST_START---")
        print(json.dumps(delegation_request))
        print("---DELEGATION_REQUEST_END---")
        sys.stdout.flush()

        # Read response from STDIN (Claude Code provides this)
        logger.info("‚è≥ Waiting for response from Claude Code operator...")
        response_line = sys.stdin.readline()

        if not response_line:
            raise RuntimeError("No response from Claude Code operator (STDIN closed)")

        # Parse response
        try:
            response = json.loads(response_line)
            logger.info("‚úÖ Received response from Claude Code operator")
            return response.get("result", {})
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse Claude Code response: {e}")
            raise RuntimeError(f"Invalid response from Claude Code operator: {response_line}")

    def _run_autonomous(self, project_id: str) -> None:
        """
        Run orchestrator in autonomous mode (direct execution, no handoff).

        Args:
            project_id: Project ID
        """
        logger.info("‚ö° Running in autonomous mode (no Claude Code integration)")

        # Launch orchestrator directly
        cmd = [
            sys.executable,
            str(self.orchestrator_path),
            str(self.repo_root),
            project_id,
            "--mode=autonomous"
        ]

        result = subprocess.run(cmd)
        sys.exit(result.returncode)


def main():
    """CLI entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description="VIBE CLI - Agency OS Command Line Interface",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Run project in delegated mode (default - MVP)
  vibe-cli run my-project-123

  # Run in autonomous mode (standalone - deferred to v1.1)
  vibe-cli run my-project-123 --mode=autonomous

Notes:
  - MVP uses DELEGATION ONLY mode
  - Claude Code operator provides intelligence (not vibe-cli)
  - No API keys required (Claude Code handles authentication)
        """
    )

    parser.add_argument(
        'command',
        type=str,
        choices=['run'],
        help='Command to execute'
    )
    parser.add_argument(
        'project_id',
        type=str,
        help='Project ID'
    )
    parser.add_argument(
        '--mode',
        type=str,
        choices=['delegated', 'autonomous'],
        default='delegated',
        help='Execution mode (default: delegated)'
    )
    parser.add_argument(
        '--repo-root',
        type=Path,
        default=Path.cwd(),
        help='Repository root (default: current directory)'
    )

    args = parser.parse_args()

    # Initialize CLI
    cli = VibeCLI(repo_root=args.repo_root)

    # Execute command
    if args.command == 'run':
        cli.run_project(args.project_id, mode=args.mode)
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
