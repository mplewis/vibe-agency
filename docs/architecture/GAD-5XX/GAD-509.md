# GAD-509: The Iron Dome - Circuit Breaker Protocol

**Status:** ✅ IMPLEMENTED
**Date:** 2025-11-18
**Pillar:** GAD-5XX (Runtime Engineering)
**Priority:** P0 (System Stability & Resilience)

---

## Executive Summary

**GAD-509** implements the **Circuit Breaker Pattern** to protect VIBE Agency OS from cascading failures when LLM APIs experience degradation or outages.

**The Problem:** Without circuit breaker protection, sustained API failures can cause:
- System resource exhaustion from retry storms
- Cascading failures across dependent components
- Poor user experience during provider outages
- Difficulty detecting and recovering from API degradation

**The Solution:** A three-state circuit breaker (CLOSED → OPEN → HALF_OPEN) that:
- Monitors API failure rates in real-time
- Opens circuit after threshold exceeded (5 failures/60s)
- Prevents new requests during outages (fast-fail)
- Automatically probes for recovery after timeout (30s)
- Closes circuit when API health is restored

**Impact:** System remains stable during API outages, provides fast feedback to users, and automatically recovers when service is restored.

---

## Architecture

### Circuit Breaker State Machine

```
CLOSED (healthy) ──(5 failures/60s)──> OPEN (failing)
                                        │
                                        ├─(30s timeout)──> HALF_OPEN (testing)
                                        │
                                        └─(probe succeeds)──> CLOSED
```

### State Definitions

**CLOSED (Normal Operation):**
- All requests pass through to LLM provider
- Failures are tracked but don't block requests
- System operates normally with full functionality

**OPEN (Circuit Tripped):**
- New requests are immediately rejected (fast-fail)
- No calls made to degraded API
- After 30s recovery timeout, transition to HALF_OPEN

**HALF_OPEN (Testing Recovery):**
- Single probe request allowed to test API health
- Success → Return to CLOSED state
- Failure → Return to OPEN state

### Implementation Location

**Primary Implementation:**
```
agency_os/core_system/runtime/circuit_breaker.py
```

**Key Classes:**
- `CircuitBreaker` - Main implementation
- `CircuitBreakerState` - State enumeration (CLOSED, OPEN, HALF_OPEN)
- `CircuitBreakerConfig` - Configuration parameters
- `CircuitBreakerMetrics` - Telemetry and observability

**Integration Points:**
- `agency_os/core_system/runtime/llm_client.py:309` - LLM client wraps provider calls

---

## Key Decisions

### Decision 1: Failure Threshold Configuration

**Choice:** 5 failures within 60-second rolling window
**Rationale:**
- Tolerates transient failures (network blips, single rate limit hit)
- Quickly detects sustained degradation (5 failures in 1 minute = serious issue)
- Avoids false positives from occasional API hiccups

**Configuration:**
```python
CircuitBreakerConfig(
    failure_threshold=5,           # Failures before opening
    recovery_timeout_seconds=30,   # Time to wait before probe
    window_size_seconds=60,        # Rolling window for failure count
)
```

### Decision 2: Recovery Timeout

**Choice:** 30-second timeout before testing recovery
**Rationale:**
- Long enough for transient issues to clear
- Short enough for acceptable user experience
- Matches typical API provider incident response times

### Decision 3: Rolling Window vs. Consecutive Failures

**Choice:** Rolling 60-second window (not consecutive failures)
**Rationale:**
- More accurate detection of sustained issues
- Prevents "count reset" from single success during degradation
- Better handles intermittent failures

### Decision 4: Integration with LLM Client

**Choice:** Circuit breaker wraps provider invocation in `llm_client.py`
**Rationale:**
- Single point of enforcement
- Applies to all providers (Anthropic, Google, OpenAI)
- Maintains separation of concerns (provider logic vs. resilience)

---

## Implementation Status

### ✅ Implemented

**Core Circuit Breaker:**
- ✅ Three-state state machine (CLOSED, OPEN, HALF_OPEN)
- ✅ Rolling window failure tracking
- ✅ Automatic timeout-based recovery probing
- ✅ Metrics collection (requests, failures, state changes)

**Integration:**
- ✅ Integrated into `LLMClient` at `llm_client.py:309`
- ✅ Wraps all provider invocations
- ✅ Raises `CircuitBreakerOpenError` when circuit is open

**Observability:**
- ✅ Logging for state transitions
- ✅ Metrics tracking (success/failure rates)
- ✅ Status reporting via `get_status()` method

### Verification Commands

```bash
# Read implementation
cat agency_os/core_system/runtime/circuit_breaker.py

# Check integration
grep -n "circuit_breaker" agency_os/core_system/runtime/llm_client.py

# Test circuit breaker (if tests exist)
uv run pytest tests/test_circuit_breaker.py -v
```

---

## Usage Examples

### Basic Usage

```python
from agency_os.core_system.runtime.circuit_breaker import CircuitBreaker

# Initialize circuit breaker
breaker = CircuitBreaker()

# Wrap risky operation
try:
    result = breaker.call(llm_provider.invoke, prompt="...", model="...")
except CircuitBreakerOpenError:
    # API is down - use fallback strategy
    result = use_cached_response()
```

### Custom Configuration

```python
from agency_os.core_system.runtime.circuit_breaker import CircuitBreaker, CircuitBreakerConfig

# Custom thresholds for high-traffic scenarios
config = CircuitBreakerConfig(
    failure_threshold=10,           # More tolerant
    recovery_timeout_seconds=60,    # Longer recovery
    window_size_seconds=120,        # 2-minute window
)

breaker = CircuitBreaker(config=config)
```

### Monitoring Status

```python
# Get current circuit breaker status
status = breaker.get_status()

print(f"State: {status['state']}")
print(f"Failures: {status['failure_count']}/{status['failure_threshold']}")
print(f"Last error: {status['last_failure_error']}")
```

---

## Configuration

### Environment Variables

Circuit breaker uses static configuration (no environment variables).
Configuration is code-based for predictable behavior.

### Tuning Guidelines

**High-Volume Production:**
```python
CircuitBreakerConfig(
    failure_threshold=10,           # More tolerant
    recovery_timeout_seconds=60,    # Longer recovery
    window_size_seconds=120,        # Larger window
)
```

**Low-Latency Development:**
```python
CircuitBreakerConfig(
    failure_threshold=3,            # Fail fast
    recovery_timeout_seconds=10,    # Quick retry
    window_size_seconds=30,         # Small window
)
```

---

## Metrics & Observability

### Tracked Metrics

```python
{
    "state": "closed|open|half_open",
    "failure_count": 0,
    "failure_threshold": 5,
    "metrics": {
        "total_requests": 100,
        "successful_requests": 95,
        "failed_requests": 5,
        "rejected_requests": 0,
        "state_changes": 2
    }
}
```

### Logging Examples

**State Transitions:**
```
[INFO] Circuit Breaker state transition: closed → open
[INFO] Circuit Breaker state transition: open → half_open
[INFO] Circuit Breaker probe succeeded - transitioning to closed
```

**Failure Tracking:**
```
[WARNING] LLM API failure recorded: RateLimitError: Rate limit exceeded (failures: 3/5 in 60s)
[ERROR] Circuit Breaker OPENING! LLM API showing sustained issues. Failures: 5/5 in 60s.
```

---

## Cross-Pillar Dependencies

**GAD-509 depends on:**
- **GAD-510 (QuotaManager):** Both protect against API abuse
- **GAD-511 (Neural Adapter):** Circuit breaker wraps provider invocations

**Other pillars depend on GAD-509:**
- **GAD-2XX (Orchestration):** Orchestrator benefits from resilience
- **GAD-500 (Runtime Engineering):** Part of self-regulating execution

---

## Known Issues & Limitations

### Current Limitations

1. **Static Configuration:** No runtime reconfiguration without restart
2. **No Persistence:** Circuit state not persisted across restarts
3. **Single Circuit:** One global circuit for all providers (could be per-provider)

### Future Enhancements (Deferred)

**GAD-509.1: Per-Provider Circuits**
- Separate circuit breakers for Anthropic, Google, OpenAI
- Provider-specific thresholds and timeouts

**GAD-509.2: Adaptive Thresholds**
- Dynamically adjust thresholds based on historical patterns
- Machine learning for anomaly detection

**GAD-509.3: Circuit State Persistence**
- Persist circuit state to disk
- Restore state after system restart

---

## Testing Strategy

### Unit Tests (Target)

```python
def test_circuit_opens_after_threshold():
    """Circuit should open after 5 failures in 60s"""
    breaker = CircuitBreaker()

    # Trigger 5 failures
    for _ in range(5):
        try:
            breaker.call(failing_function)
        except:
            pass

    # Circuit should now be OPEN
    assert breaker.state == CircuitBreakerState.OPEN

def test_circuit_recovers_after_timeout():
    """Circuit should transition to HALF_OPEN after 30s"""
    breaker = CircuitBreaker()

    # Open circuit
    trigger_failures(breaker, count=5)

    # Wait 30s
    time.sleep(30)

    # Next call should transition to HALF_OPEN
    can_execute, reason = breaker.can_execute()
    assert can_execute == True
    assert "HALF_OPEN" in reason
```

### Integration Tests (Target)

```bash
# Test with LLM client integration
uv run pytest tests/test_llm_client_resilience.py -v
```

---

## Migration Notes

**Created:** 2025-11-18
**First Implementation:** PR #158 (Zero-Config Boot branch)

**Commits:**
- `a4d0a02`: feat(GAD-5): Implement Zero-Config Boot with auto-provisioning
- `eeca679`: feat(GAD-511): Implement Golden Thread verification and fix runtime imports

**Related Documentation:**
- This document created as part of Operation Glass Box (documentation sync)

---

## References

**Design Patterns:**
- Martin Fowler: [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- Microsoft: [Circuit Breaker Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker)

**Related GADs:**
- **GAD-510:** QuotaManager (cost control)
- **GAD-511:** Neural Adapter Strategy (provider abstraction)
- **GAD-500:** Runtime Engineering (self-regulating execution)

---

**Last Updated:** 2025-11-19
**Next Review:** After production load testing
**Maintainer:** Runtime Engineering Team
