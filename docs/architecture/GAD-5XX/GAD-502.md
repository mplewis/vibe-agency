# GAD-502: Haiku Hardening

**Formerly:** GAD-005-ADDITION  
**Status:** üìã APPROVED - Awaiting Approval  
**Created:** 2025-11-16  
**Migrated:** 2025-11-17 (Week 1 PR 1)  
**Type:** Multi-Dimensional Work Package (Spectrum across GAD-004/005)

**SEMANTIC CLARIFICATION (2025-11-17):**

**"Haiku" in this document refers to:**
- ‚úÖ A less capable operator model (Claude Haiku vs Sonnet/Opus)
- ‚úÖ Testing delegation architecture with cheaper/faster models
- ‚úÖ Validation that Claude Code operator using Haiku can complete workflows

**"Haiku" does NOT mean:**
- ‚ùå Direct Haiku API integration into vibe-agency
- ‚ùå vibe-cli making Anthropic API calls (forbidden in MVP)
- ‚ùå Standalone mode with model selection (deferred to v2)

**Architecture Context:**
- **Operator:** Claude Code (person/agent using the tool)
- **Model:** Sonnet/Opus/Haiku (operator's choice, NOT vibe-agency's)
- **vibe-cli:** Delegation bridge only (NO API calls per EXECUTION_MODE_STRATEGY.md)

See: [GAD-502-SEMANTIC-CLARIFICATION.md](./GAD-502-SEMANTIC-CLARIFICATION.md) for details.

---

## üåà THE SPECTRUM (Not One-Dimensional)

**This work package spans multiple GAD pillars:**

```
GAD-004: Quality Enforcement ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚Üì Validation aspect:                    ‚îÇ
  - Test if quality enforcement works     ‚îÇ
  - Adversarial testing (rogue scenarios) ‚îÇ
  - Measure protection coverage           ‚îÇ
                                          ‚îÇ
GAD-005: Runtime Engineering ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SPECTRUM
  ‚Üì Improvement aspect:                   ‚îÇ
  - Harden kernel (shell checks)          ‚îÇ
  - Improve MOTD (critical alerts)        ‚îÇ
  - Enhance errors (Haiku-readable)       ‚îÇ
  - Add recovery (escalation)             ‚îÇ
                                          ‚îÇ
FINAL ENFORCEMENT: CI/CD ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì End point:
  - If runtime fails ‚Üí wipe ‚Üí next agent
  - Runtime is the LAST LINE OF DEFENSE
```

**Why it's a spectrum:**
- **Starts** with validation (GAD-004: "Does defense-in-depth work?")
- **Continues** with hardening (GAD-005: "Close the gaps we found")
- **Ends** with runtime enforcement (CI/CD wipe if agent breaks through)

---

## üéØ OBJECTIVE

**Make vibe-agency operable by less capable AI agents (Claude Haiku or dumber) without risk of rogue behavior.**

**Why this matters:**

1. **üí∞ Cost Efficiency** (10-20x cheaper)
   - Haiku: $0.25/MTok input, $1.25/MTok output
   - Sonnet: $3/MTok input, $15/MTok output
   - For simple tasks (linting, file ops), Haiku is sufficient

2. **üõ°Ô∏è True Defense-in-Depth Validation**
   - We CLAIM robust guardrails (GAD-004/005)
   - Haiku hardening PROVES it works for worst-case agents
   - "If Haiku can't break it, nothing can"

3. **üöÄ Foundation for Autonomy**
   - GAD-007/008 (autonomous operation) requires this
   - Can't have autonomous agents hallucinating into critical files
   - Haiku-proof = autonomous-ready

4. **üë• Human Benefits Too**
   - Simplifications that help Haiku also help humans
   - Clearer errors, better MOTD, simpler recovery paths
   - Better onboarding for new developers

---

## üìä CURRENT STATE

### Protection Coverage: 2/19 scenarios (10.5%)

| Vulnerability Category | Scenarios | Protected | Status |
|------------------------|-----------|-----------|--------|
| Shell bypasses | 3 | 0 | ‚ùå VULNERABLE |
| Git bypasses | 1 | 0 | ‚ùå VULNERABLE |
| Hallucinations | 2 | 0 | ‚ùå VULNERABLE |
| Context overload | 2 | 0 | ‚ùå VULNERABLE |
| Error loops | 2 | 0 | ‚ùå VULNERABLE |
| Misinterpretation | 3 | 1 | ‚ö†Ô∏è PARTIAL (MOTD alerts ignored) |
| Recovery guidance | 6 | 1 | ‚ö†Ô∏è PARTIAL (kernel blocks but no examples) |
| **TOTAL** | **19** | **2** | **10.5%** |

### Identified Vulnerabilities

**CRITICAL (Shell/Git Bypasses):**
```bash
# ‚ùå Agent can bypass kernel using shell commands
echo '{}' > manifest.json           # Overwrites critical file
git push origin main                # Skips pre-push checks
rm -rf .vibe/                       # Deletes system integrity dir
sed -i 's/phase/HACKED/' manifest.json  # Direct file manipulation
```

**HIGH (Hallucinations):**
```bash
# ‚ùå Agent invents commands/files that don't exist
./bin/quick-fix.sh                  # Doesn't exist, no helpful error
vibe-cli --auto-fix                 # Flag doesn't exist, confusing error
```

**MEDIUM (Context Overload):**
```
# ‚ùå Agent misses critical details in long prompts/MOTD
- CLAUDE.md: 450 lines (too long for Haiku attention span)
- Agent prompts: Some 200+ lines (critical details buried)
- MOTD: 15+ lines (alerts buried in middle)
```

**LOW (Error Loops):**
```python
# ‚ùå Agent retries same failed operation 3+ times
# No escalation, no "you're stuck, ask operator" message
```

---

## üèóÔ∏è IMPLEMENTATION PLAN

### Phase 1: Test Harness ‚úÖ COMPLETE

**Deliverables:**
- ‚úÖ `tests/test_rogue_agent_scenarios.py` (19 test scenarios)
- ‚úÖ Test categories: Hallucination, Bypass, Misinterpretation, Context Overload, Recovery
- ‚úÖ Clear pass/fail criteria for each scenario

**Evidence:**
```bash
uv run pytest tests/test_rogue_agent_scenarios.py -v
# Current: 1 failed, 1 passed, 11 skipped (implementation pending)
```

---

### Phase 2: Shell-Level Guardrails (Week 3)

**Problem:** Kernel only blocks Python operations, not shell commands.

**Solution:** Add shell command kernel checks.

**Implementation:**
```python
# In agency_os/core_system/orchestrator/core_orchestrator.py

def _kernel_check_shell_command(self, command: str) -> None:
    """
    Kernel check: Block dangerous shell operations.

    Prevents shell-based bypasses of Python kernel checks.
    Runs BEFORE executing any shell command.
    """
    import re
    import shlex

    # Parse command safely
    try:
        tokens = shlex.split(command)
    except ValueError:
        return  # Malformed command - let shell handle error

    # Dangerous patterns (regex, error message, remediation)
    patterns = [
        # Critical file overwrites
        (r'(echo|cat|sed|awk).*>\s*(manifest\.json|\.session_handoff\.json)',
         "Cannot overwrite critical files via shell",
         "Use: orchestrator.save_artifact('manifest', data)"),

        # Git operations without checks
        (r'git\s+push(?!\s+.*--dry-run)',
         "Cannot push without pre-push checks",
         "Use: ./bin/pre-push-check.sh && git push"),

        # System integrity violations
        (r'(rm|mv|cp|chmod).*\.vibe/',
         "Cannot modify system integrity directory",
         "This directory is protected by Layer 0 verification"),

        # Direct manifest edits
        (r'(vim|nano|emacs|ed|vi).*manifest\.json',
         "Cannot directly edit manifest.json",
         "Use: orchestrator.save_artifact('manifest', updated_data)"),
    ]

    for pattern, message, remediation in patterns:
        if re.search(pattern, command):
            raise KernelViolationError(
                operation=f"Shell command: {command}",
                why=message,
                remediation=[remediation, "If stuck, ask operator for help"],
                example_good=remediation,
                example_bad=command,
            )
```

**Integration Points:**
1. vibe-cli: Check before `subprocess.run()`
2. core_orchestrator: Check before task execution
3. Manual testing: Try bypass attempts, verify blocking

**Test Coverage:**
```python
# In tests/test_rogue_agent_scenarios.py

def test_agent_overwrites_manifest_via_shell():
    """Agent tries: echo '{}' > manifest.json"""
    orchestrator = CoreOrchestrator(...)

    with pytest.raises(KernelViolationError) as exc:
        orchestrator._kernel_check_shell_command("echo '{}' > manifest.json")

    assert "Cannot overwrite critical files" in str(exc.value)
    assert "orchestrator.save_artifact" in str(exc.value)

def test_agent_pushes_without_precheck():
    """Agent tries: git push origin main"""
    with pytest.raises(KernelViolationError) as exc:
        orchestrator._kernel_check_shell_command("git push origin main")

    assert "pre-push checks" in str(exc.value)
    assert "./bin/pre-push-check.sh" in str(exc.value)

def test_agent_modifies_vibe_directory():
    """Agent tries: rm -rf .vibe/"""
    with pytest.raises(KernelViolationError) as exc:
        orchestrator._kernel_check_shell_command("rm -rf .vibe/")

    assert "system integrity" in str(exc.value)
```

**Deliverables:**
- `_kernel_check_shell_command()` method (~60 LOC)
- Integration into vibe-cli and orchestrator (~20 LOC)
- 5+ tests passing in `test_rogue_agent_scenarios.py`
- Target: 8/19 scenarios protected (42%)

**Estimated Effort:** 2-3 hours

---

### Phase 3: Simplified Error Messages (Week 3)

**Problem:** Current errors assume agent intelligence.

**Solution:** Make ALL errors "Haiku-readable" with clear structure.

**Error Message Template:**
```
üö´ BLOCKED: [What you tried to do]

WHY: [Simple 1-sentence explanation, no jargon]

WHAT TO DO INSTEAD:
  1. [Primary solution with exact command]
  2. [Alternative approach]
  3. [If stuck: Ask operator]

EXAMPLE:
  ‚úÖ [Working code - copy-pasteable]
  ‚ùå [What you just tried]
```

**Implementation:**
```python
# Refactor KernelViolationError in core_orchestrator.py

class KernelViolationError(Exception):
    """
    Kernel violation with Haiku-readable error message.

    All errors MUST include:
    - Simple explanation (1 sentence, no jargon)
    - Actionable remediation (numbered steps)
    - Working example (copy-pasteable)
    """

    def __init__(
        self,
        operation: str,          # What they tried to do
        why: str,                # Simple 1-sentence explanation
        remediation: list[str],  # Numbered action steps
        example_good: str,       # Working code
        example_bad: str,        # What they tried
        learn_more: str = None   # Optional doc link
    ):
        self.operation = operation
        self.why = why
        self.remediation = remediation
        self.example_good = example_good
        self.example_bad = example_bad
        self.learn_more = learn_more

    def __str__(self):
        msg = f"üö´ BLOCKED: {self.operation}\n\n"
        msg += f"WHY: {self.why}\n\n"
        msg += "WHAT TO DO INSTEAD:\n"
        for i, step in enumerate(self.remediation, 1):
            msg += f"  {i}. {step}\n"
        msg += f"\nEXAMPLE:\n"
        msg += f"  ‚úÖ {self.example_good}\n"
        msg += f"  ‚ùå {self.example_bad}\n"
        if self.learn_more:
            msg += f"\nüìö LEARN MORE: {self.learn_more}\n"
        return msg
```

**Example Usage:**
```python
# Before
raise KernelViolationError("Cannot overwrite manifest.json")

# After
raise KernelViolationError(
    operation="You tried to overwrite manifest.json",
    why="This file tracks project state. Overwriting breaks the system.",
    remediation=[
        "Use: orchestrator.save_artifact('manifest', updated_data)",
        "Or check current: cat manifest.json | jq .",
        "If stuck, ask operator: 'How do I update manifest?'",
    ],
    example_good="orchestrator.save_artifact('manifest', {'phase': 'CODING'})",
    example_bad="echo '{}' > manifest.json",
    learn_more="docs/architecture/ARTIFACT_REGISTRY.md"
)
```

**Test Coverage:**
```python
def test_kernel_error_is_haiku_readable():
    """Error message must be understandable by Haiku-level agent."""
    with pytest.raises(KernelViolationError) as exc:
        orchestrator._kernel_check_save_artifact("manifest.json")

    error_msg = str(exc.value)

    # Must have all required sections
    assert "üö´ BLOCKED:" in error_msg
    assert "WHY:" in error_msg
    assert "WHAT TO DO INSTEAD:" in error_msg
    assert "EXAMPLE:" in error_msg
    assert "‚úÖ" in error_msg  # Good example
    assert "‚ùå" in error_msg  # Bad example

    # Must be concise (< 500 chars)
    assert len(error_msg) < 500

    # Must have numbered steps
    assert "1." in error_msg

    # Must have working example (copy-pasteable)
    assert "orchestrator.save_artifact" in error_msg
```

**Deliverables:**
- Updated `KernelViolationError` class (~40 LOC)
- Refactor all 3 existing kernel checks (~30 LOC)
- 3+ tests validating error message structure
- Target: 11/19 scenarios protected (58%)

**Estimated Effort:** 2-3 hours

---

### Phase 4: MOTD Critical Alerts (Week 4)

**Problem:** MOTD is 15+ lines, Haiku might miss critical alerts.

**Solution:** Add "CRITICAL ALERTS" section at top, limit to 3 most important items.

**New MOTD Structure:**
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üö® CRITICAL ALERTS (READ THIS FIRST!)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  ‚ùå LINTING FAILED - Run: uv run ruff check . --fix
  ‚ö†Ô∏è  DIRTY GIT - 3 files uncommitted

‚úÖ System Health
  Git: ‚ö†Ô∏è Dirty | Linting: ‚ùå 12 errors | Tests: ‚úÖ 107/107

üì¨ Session Handoff: From VIBE_ALIGNER
  ‚úÖ Completed: Feature specification
  üìã TODOs (3): Select modules, Design extensions, ...

‚ö° Quick Commands
  ./bin/show-context.sh    # Full context
  ./bin/pre-push-check.sh  # Run all checks
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
```

**Implementation:**
```python
# In vibe-cli

def _get_critical_alerts(system_status: dict) -> list[str]:
    """
    Extract top 3 critical alerts that agent MUST see.

    Priority:
    1. System integrity failures (CRITICAL - system compromised)
    2. Linting errors (blocks commits)
    3. Test failures (indicates broken code)
    4. Dirty git (warns before transitions)
    """
    alerts = []

    # System integrity (highest priority)
    if not system_status.get("system_integrity", {}).get("verified", True):
        alerts.append("‚ùå SYSTEM INTEGRITY FAILED - Run: python scripts/verify-system-integrity.py")

    # Linting (blocks commits)
    linting = system_status.get("linting", {})
    if linting.get("status") == "failed":
        count = linting.get("error_count", 0)
        alerts.append(f"‚ùå LINTING FAILED - Run: uv run ruff check . --fix")

    # Tests (broken code)
    tests = system_status.get("tests", {})
    if tests.get("status") == "failed":
        count = tests.get("failed", 0)
        alerts.append(f"‚ùå TESTS FAILING ({count} failed) - Run: uv run pytest")

    # Git (warns before operations)
    git = system_status.get("git", {})
    if git.get("status") == "dirty":
        count = len(git.get("uncommitted_files", []))
        alerts.append(f"‚ö†Ô∏è  DIRTY GIT - {count} files uncommitted")

    return alerts[:3]  # Max 3 alerts

def display_motd():
    """Display MOTD with critical alerts at top."""
    system_status = _get_system_status()
    critical_alerts = _get_critical_alerts(system_status)

    print("‚îÅ" * 80)

    # Critical alerts ALWAYS shown first
    if critical_alerts:
        print("üö® CRITICAL ALERTS (READ THIS FIRST!)")
        print("‚îÅ" * 80)
        for alert in critical_alerts:
            print(f"  {alert}")
        print()
    else:
        print("‚úÖ No critical alerts - system healthy")
        print("‚îÅ" * 80)

    # Rest of MOTD (condensed if alerts exist)
    # ...
```

**Deliverables:**
- `_get_critical_alerts()` function (~40 LOC)
- Updated `display_motd()` (~20 LOC)
- 5+ tests validating alert prioritization
- Target: 15/19 scenarios protected (79%)

**Estimated Effort:** 2 hours

---

### Phase 5: Recovery Playbooks (Week 4)

**Problem:** When kernel blocks, agent doesn't know how to recover.

**Solution:** Track violations, escalate on repeated failures.

**Implementation:**
```python
# In core_orchestrator.py

class CoreOrchestrator:
    def __init__(self, ...):
        # ... existing code
        self._kernel_violations: dict[str, int] = {}

    def _record_kernel_violation(self, violation_type: str) -> int:
        """Record violation attempt, return count (1-indexed)."""
        self._kernel_violations[violation_type] = \
            self._kernel_violations.get(violation_type, 0) + 1
        return self._kernel_violations[violation_type]

    def _kernel_check_save_artifact(self, artifact_name: str) -> None:
        """Kernel check with escalation."""
        if artifact_name in self.CRITICAL_ARTIFACTS:
            attempts = self._record_kernel_violation(f"overwrite_{artifact_name}")

            if attempts == 1:
                # First: Helpful error
                raise KernelViolationError(
                    operation=f"You tried to overwrite {artifact_name}",
                    why="This file is protected.",
                    remediation=[
                        f"Use: orchestrator.save_artifact('{artifact_name}', data)",
                    ],
                    example_good=f"orchestrator.save_artifact('{artifact_name}', new_data)",
                    example_bad=f"echo '{{}}' > {artifact_name}",
                )
            elif attempts == 2:
                # Second: More explicit
                raise KernelViolationError(
                    operation=f"SECOND ATTEMPT to overwrite {artifact_name}",
                    why="This operation is BLOCKED (not a warning).",
                    remediation=[
                        "STOP trying to overwrite directly",
                        f"Use: orchestrator.save_artifact('{artifact_name}', data)",
                        "If confused, ask operator: 'How do I update manifest?'",
                    ],
                    example_good=f"orchestrator.save_artifact('{artifact_name}', data)",
                    example_bad="ANY direct file write",
                )
            else:
                # Third+: Escalate to operator
                raise KernelViolationError(
                    operation=f"REPEATED VIOLATION ({attempts}x) - overwrite {artifact_name}",
                    why="You have tried multiple times. This is BLOCKED BY DESIGN.",
                    remediation=[
                        "üö® YOU NEED OPERATOR HELP üö®",
                        "Ask: 'I'm blocked trying to update manifest. What am I doing wrong?'",
                        "Do NOT retry this operation",
                    ],
                    example_good="[Ask operator - you're stuck in a loop]",
                    example_bad=f"Trying same operation {attempts} times",
                )
```

**Deliverables:**
- `_record_kernel_violation()` method (~10 LOC)
- Escalation logic in kernel checks (~30 LOC)
- 5+ tests validating escalation
- Target: 19/19 scenarios protected (100%)

**Estimated Effort:** 2 hours

---

### Phase 6: Operator Model Validation (Week 5) - OPTIONAL

**Goal:** Test with Claude Code operator using Haiku model to validate hardening works.

**IMPORTANT:** This is NOT about adding Haiku API integration to vibe-agency.
Per EXECUTION_MODE_STRATEGY.md, vibe-cli MUST NOT make API calls in MVP.

This phase validates that the DELEGATION architecture works when the 
Claude Code operator chooses to use a less capable model (Haiku instead of Sonnet).
The operator controls model selection, not vibe-agency.

**Approach:**
1. Have operator use Haiku model to execute PLANNING workflow (via delegation)
2. Measure: How many mistakes did kernel prevent?
3. Data-driven proof of "Haiku-proof" claims

**Why Optional:**
- Requires operator to manually switch to Haiku model
- Costs tokens (good use of free credits!)
- Phases 2-5 already provide strong coverage via unit tests
- Manual validation process (not automated)

**If Implemented:**

Manual validation procedure:
1. Setup test project: `./vibe-cli init haiku-validation-test`
2. Operator switches Claude Code to Haiku model
3. Execute workflow: `./vibe-cli run haiku-validation-test`
4. Operator responds to delegation requests using Haiku model
5. Measure and document results

```python
class OperatorModelValidator:
    """Validate system works with less capable operator models (e.g., Haiku)."""

    def test_planning_workflow(self):
        # Operator (you!) should switch Claude Code to Haiku model
        # Then execute: ./vibe-cli run test-project
        # This test validates the delegation works with less capable models
        result = run_delegated_workflow("test-project")

        # Measure protection
        return {
            "succeeded": result.success,
            "kernel_violations_prevented": len(result.violations),
            "mistakes_caught": result.violations,
        }
```

**Deliverables:**
- Delegation test harness (~50 LOC)
- Planning workflow validation procedure (~30 LOC documentation)
- Metrics report (prevention rate, common mistakes)

NOTE: No API integration needed - validation is manual (operator switches model)

**Estimated Effort:** 3 hours

---

## üìä SUCCESS METRICS

| Metric | Current | Phase 2 | Phase 3 | Phase 4 | Phase 5 | Target |
|--------|---------|---------|---------|---------|---------|--------|
| Scenarios protected | 2/19 | 8/19 | 11/19 | 15/19 | 19/19 | 19/19 |
| Protection % | 10.5% | 42% | 58% | 79% | 100% | 100% |
| Shell bypass vulnerabilities | 3 | 0 | 0 | 0 | 0 | 0 |
| Errors with examples | 33% | 33% | 100% | 100% | 100% | 100% |
| MOTD critical alerts | 0 | 0 | 0 | 3 | 3 | 3 |
| Violation escalation | None | None | None | None | 3-tier | 3-tier |

---

## üéØ ACCEPTANCE CRITERIA

**Phase 2 Complete When:**
- [ ] Shell bypass tests pass (3/3)
- [ ] `_kernel_check_shell_command()` implemented
- [ ] Zero regression in existing tests

**Phase 3 Complete When:**
- [ ] All kernel errors use new format (3/3)
- [ ] Error structure tests pass (3/3)
- [ ] Manual review: Understandable by non-technical user

**Phase 4 Complete When:**
- [ ] MOTD shows max 3 critical alerts at top
- [ ] Alert prioritization tests pass (3/3)
- [ ] Manual review: MOTD scannable in <5 seconds

**Phase 5 Complete When:**
- [ ] Violation tracking implemented
- [ ] Escalation tests pass (5/5)
- [ ] Third violation suggests operator help

**Overall Success:**
- [ ] 19/19 rogue scenario tests passing
- [ ] Manual validation: Operator using Haiku model completes PLANNING workflow (optional)
- [ ] Zero regression (107+ existing tests still pass)
- [ ] No API integration added (delegation-only architecture preserved)

---

## üîó RELATIONSHIP TO OTHER GADs

### Spans Multiple Pillars (Spectrum):

**GAD-004: Quality Enforcement**
- Validates defense-in-depth actually works
- Adversarial testing (rogue agent scenarios)
- Measures protection coverage

**GAD-005: Runtime Engineering**
- Hardens runtime guardrails (kernel, MOTD)
- Improves error communication
- Adds recovery guidance

**Final Enforcement: CI/CD**
- If runtime fails ‚Üí wipe ‚Üí next agent
- Runtime is LAST LINE OF DEFENSE
- Haiku-hardening ensures runtime catches everything

### Enables Future Work:

**GAD-007: Autonomous Operation (hypothetical)**
- Requires Haiku-proof architecture
- Can't have autonomous agents hallucinating
- Haiku-hardening is prerequisite

---

## üí≠ DESIGN PHILOSOPHY

**Core Principle:** Intelligence-independent safety

1. **System should be "idiot-proof"**
   - Even dumb agents can't break critical files
   - Don't rely on agent smartness for safety

2. **Errors should teach, not just block**
   - Help agent learn correct approach
   - Provide working examples, not just "no"

3. **Escalate gracefully**
   - First: Helpful error
   - Second: Explicit warning
   - Third: Operator intervention

4. **Simplicity beats sophistication**
   - If Haiku can't understand it, simplify it
   - Clear > clever

---

## üìÖ TIMELINE

**Total Effort:** 8-11 hours (Phases 2-5)

- Phase 2: Shell guardrails (2-3 hours)
- Phase 3: Error messages (2-3 hours)
- Phase 4: MOTD alerts (2 hours)
- Phase 5: Recovery playbooks (2 hours)
- Phase 6: Validation (3 hours) - OPTIONAL

**Dependencies:** None (builds on GAD-005)

**Risk:** Low (additive changes, clear tests, no core rewrites)

---

## ‚úÖ APPROVAL CHECKLIST

Before starting implementation:

- [ ] Review this document
- [ ] Decide on Phase 6 (Haiku simulation) - worth the effort?
- [ ] Confirm success threshold (100% or is 79% acceptable?)
- [ ] Approve timeline (8-11 hours over 2 weeks)
- [ ] Green light to start Phase 2

---

**Created:** 2025-11-16
**Author:** Claude Code (Sonnet 4.5)
**Status:** üìã DRAFT - Awaiting Approval
**Next Step:** Start Phase 2 (shell guardrails) after approval
