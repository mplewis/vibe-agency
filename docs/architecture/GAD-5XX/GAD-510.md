# GAD-510: Cost Control - Operational Quota Manager

**Status:** ✅ IMPLEMENTED
**Date:** 2025-11-18
**Pillar:** GAD-5XX (Runtime Engineering)
**Priority:** P0 (Cost Management & Safety)

---

## Executive Summary

**GAD-510** implements the **Operational Quota Manager** to prevent surprise cost spikes and API rate limit violations during LLM operations.

**The Problem:** Without quota enforcement:
- Runaway operations can generate unexpected API costs
- Rate limit hits cause service disruptions
- No visibility into resource consumption patterns
- Difficult to budget and forecast LLM costs

**The Solution:** Pre-flight and post-flight quota tracking that enforces:
- **Requests Per Minute (RPM):** Prevent API rate limit hits
- **Tokens Per Minute (TPM):** Control token consumption rate
- **Cost Per Hour:** Prevent hourly cost spikes
- **Cost Per Day:** Enforce daily budget limits

**Impact:** System provides cost predictability, prevents budget overruns, and enables safe production deployment.

---

## Architecture

### Quota Enforcement Flow

```
Request Incoming
    ↓
Pre-Flight Check (check_before_request)
    ├─ Check RPM limit
    ├─ Check TPM limit
    ├─ Estimate cost
    ├─ Check hourly limit
    └─ Check daily limit
    ↓
[Execute Request if all checks pass]
    ↓
Post-Flight Recording (record_request)
    ├─ Record actual tokens used
    ├─ Record actual cost
    ├─ Update rolling windows
    └─ Emit warnings at 80% thresholds
```

### Implementation Location

**Primary Implementation:**
```
agency_os/00_system/runtime/quota_manager.py
```

**Key Classes:**
- `OperationalQuota` - Main quota manager
- `QuotaLimits` - Configurable limit thresholds
- `QuotaMetrics` - Usage tracking and metrics
- `QuotaExceededError` - Exception raised when limits hit

**Integration Points:**
- `agency_os/00_system/runtime/llm_client.py:289` - Pre-flight check
- `agency_os/00_system/runtime/llm_client.py:323` - Post-flight recording
- `agency_os/config/phoenix.py:99-123` - Configuration loading

---

## Key Decisions

### Decision 1: Environment-Configurable Limits (GAD-510.1)

**Choice:** Load quota limits from environment variables with safe defaults
**Rationale:**
- Different environments need different limits (dev vs. prod)
- Enables per-deployment budget customization
- Safe defaults prevent accidental overspending

**Environment Variables:**
```bash
VIBE_QUOTA_REQUESTS_PER_MINUTE=10       # RPM limit
VIBE_QUOTA_TOKENS_PER_MINUTE=10000      # TPM limit
VIBE_QUOTA_COST_PER_HOUR_USD=2.0        # Hourly cost cap
VIBE_QUOTA_COST_PER_DAY_USD=5.0         # Daily cost cap
```

**Defaults (Conservative):**
```python
QuotaLimits(
    requests_per_minute=10,          # Safe for dev
    tokens_per_minute=10000,         # ~10 typical requests
    cost_per_request_usd=0.50,       # Block expensive single calls
    cost_per_hour_usd=2.0,           # $2/hour = $48/day max
    cost_per_day_usd=5.0,            # $5/day cap
)
```

### Decision 2: Pre-Flight Enforcement vs. Post-Flight Tracking

**Choice:** Both - pre-flight blocks, post-flight records actuals
**Rationale:**
- Pre-flight prevents quota violations before spending money
- Post-flight tracks actual usage for accurate accounting
- Enables proactive warnings at 80% thresholds

### Decision 3: Rolling Time Windows

**Choice:** Rolling windows (not fixed hourly/daily reset)
**Rationale:**
- Smoother rate limiting (no "rush at midnight" behavior)
- More accurate representation of sustained load
- Better protection against burst traffic

**Window Sizes:**
- **Minute:** 60 seconds rolling
- **Hour:** 3600 seconds rolling
- **Day:** 86400 seconds rolling

### Decision 4: Phoenix Config Integration

**Choice:** Load limits from Phoenix Config with fallback to environment
**Rationale:**
- Single source of configuration truth
- Automatic .env file loading (Zero-Config Boot)
- Graceful degradation if Phoenix unavailable

---

## Implementation Status

### ✅ Implemented

**Core Quota Manager:**
- ✅ RPM (requests per minute) enforcement
- ✅ TPM (tokens per minute) enforcement
- ✅ Hourly cost limit enforcement
- ✅ Daily cost limit enforcement
- ✅ Per-request cost limit (blocks expensive single calls)
- ✅ Rolling time windows (minute, hour, day)

**Configuration (GAD-510.1):**
- ✅ Environment variable loading (`VIBE_QUOTA_*`)
- ✅ Phoenix Config integration
- ✅ Safe default values
- ✅ Fallback chain (Phoenix → env vars → defaults)

**Integration:**
- ✅ Pre-flight check in `LLMClient.invoke()` at line 289
- ✅ Post-flight recording at line 323
- ✅ Automatic cost estimation based on Claude Sonnet pricing

**Observability:**
- ✅ Warning logs at 80% threshold
- ✅ Detailed error messages with remaining capacity
- ✅ Status reporting via `get_status()` method

### Verification Commands

```bash
# Read implementation
cat agency_os/00_system/runtime/quota_manager.py

# Check integration
grep -n "quota_manager" agency_os/00_system/runtime/llm_client.py

# Check config
cat agency_os/config/phoenix.py | grep -A 20 "class QuotaConfig"

# Test quota manager
uv run pytest tests/test_quota_manager.py -v
```

---

## Usage Examples

### Basic Usage (Auto-Configuration)

```python
from agency_os.00_system.runtime.quota_manager import OperationalQuota

# Load limits from environment/Phoenix config
quota = OperationalQuota()

# Pre-flight check
try:
    quota.check_before_request(
        estimated_tokens=5000,
        operation="feature_implementation"
    )
except QuotaExceededError as e:
    print(f"Quota exceeded: {e}")
    return

# Execute request (your LLM call here)
response = llm.invoke(...)

# Record actual usage
quota.record_request(
    tokens_used=4800,
    cost_usd=0.24,
    operation="feature_implementation"
)
```

### Custom Configuration

```python
from agency_os.00_system.runtime.quota_manager import OperationalQuota, QuotaLimits

# High-volume production limits
limits = QuotaLimits(
    requests_per_minute=100,
    tokens_per_minute=100_000,
    cost_per_request_usd=1.0,
    cost_per_hour_usd=50.0,
    cost_per_day_usd=500.0,
)

quota = OperationalQuota(limits=limits)
```

### Monitoring Quota Status

```python
# Get current quota usage
status = quota.get_status()

print(f"RPM: {status['requests']['this_minute']}/{status['requests']['limit']}")
print(f"TPM: {status['tokens']['this_minute']}/{status['tokens']['limit']}")
print(f"Hourly Cost: ${status['cost']['this_hour_usd']}/{status['cost']['limit_per_hour_usd']}")
print(f"Daily Cost: ${status['cost']['this_day_usd']}/{status['cost']['limit_per_day_usd']}")
```

---

## Configuration

### Environment Variables

```bash
# Quota Limits
VIBE_QUOTA_REQUESTS_PER_MINUTE=10        # Max requests/minute
VIBE_QUOTA_TOKENS_PER_MINUTE=10000       # Max tokens/minute
VIBE_QUOTA_COST_PER_HOUR_USD=2.0         # Max $/hour
VIBE_QUOTA_COST_PER_DAY_USD=5.0          # Max $/day
```

### Configuration Profiles

**Development (Default):**
```bash
VIBE_QUOTA_REQUESTS_PER_MINUTE=10
VIBE_QUOTA_TOKENS_PER_MINUTE=10000
VIBE_QUOTA_COST_PER_HOUR_USD=2.0
VIBE_QUOTA_COST_PER_DAY_USD=5.0
```

**Production (High-Volume):**
```bash
VIBE_QUOTA_REQUESTS_PER_MINUTE=100
VIBE_QUOTA_TOKENS_PER_MINUTE=100000
VIBE_QUOTA_COST_PER_HOUR_USD=50.0
VIBE_QUOTA_COST_PER_DAY_USD=500.0
```

**Testing (Minimal):**
```bash
VIBE_QUOTA_REQUESTS_PER_MINUTE=5
VIBE_QUOTA_TOKENS_PER_MINUTE=5000
VIBE_QUOTA_COST_PER_HOUR_USD=1.0
VIBE_QUOTA_COST_PER_DAY_USD=2.0
```

---

## Cost Estimation

### Claude Sonnet Pricing (Default)

The quota manager uses **Claude 3.5 Sonnet** pricing for cost estimation:

```
Input:  $3.00 per million tokens
Output: $15.00 per million tokens
```

**Estimation Strategy (Conservative):**
```python
# Assume 50% input, 50% output (worst-case)
input_tokens = estimated_tokens // 2
output_tokens = estimated_tokens - input_tokens

input_cost = (input_tokens / 1_000_000) * 3.0
output_cost = (output_tokens / 1_000_000) * 15.0

total_cost = input_cost + output_cost
```

**Example:**
```
10,000 tokens = 5,000 input + 5,000 output
Cost = (5000/1M × $3) + (5000/1M × $15)
     = $0.015 + $0.075
     = $0.09
```

---

## Metrics & Observability

### Tracked Metrics

```python
{
    "requests": {
        "this_minute": 8,
        "limit": 10,
        "percent_used": 80.0
    },
    "tokens": {
        "this_minute": 7500,
        "limit": 10000,
        "percent_used": 75.0
    },
    "cost": {
        "this_hour_usd": 1.45,
        "limit_per_hour_usd": 2.0,
        "this_day_usd": 3.22,
        "limit_per_day_usd": 5.0,
        "total_usd": 12.67
    },
    "totals": {
        "total_requests": 142,
        "total_tokens": 567890,
        "quota_violations": 0
    }
}
```

### Warning Thresholds

**80% Threshold Warnings:**
```python
if current_cost > limit * 0.8:
    logger.warning(f"Hourly cost at 80% of limit: ${current:.2f}/${limit:.2f}")
```

**Logging Examples:**
```
[INFO] Request recorded: feature_implementation (4800 tokens, $0.2400). Running totals - RPM: 8, TPM: 7500, Hour: $1.45, Day: $3.22
[WARNING] Hourly cost at 80% of limit: $1.65/$2.00
[ERROR] Quota check failed: Hourly cost limit would be exceeded: $2.15/$2.00. Request cost: $0.24
```

---

## Cross-Pillar Dependencies

**GAD-510 depends on:**
- **GAD-100 (Phoenix Config):** Loads quota limits from configuration
- **GAD-511 (Neural Adapter):** Quota manager wraps provider calls

**Other pillars depend on GAD-510:**
- **GAD-2XX (Orchestration):** Orchestrator uses quotas for cost control
- **GAD-500 (Runtime Engineering):** Part of self-regulating execution

---

## Known Issues & Limitations

### Current Limitations

1. **Single Pricing Model:** Uses Claude Sonnet pricing for all providers
2. **No Persistence:** Quota state not persisted across restarts
3. **Conservative Estimation:** Assumes 50/50 input/output split

### Future Enhancements (Deferred)

**GAD-510.2: Per-Provider Pricing**
- Support different pricing models for Anthropic, Google, OpenAI
- Dynamic pricing based on actual provider rates

**GAD-510.3: Quota State Persistence**
- Persist quota state to disk
- Restore usage counters after restart
- Prevents quota reset gaming

**GAD-510.4: Advanced Cost Prediction**
- Machine learning for cost prediction
- Historical pattern analysis
- Better input/output ratio estimation

---

## Testing Strategy

### Unit Tests (Target)

```python
def test_quota_enforces_rpm_limit():
    """Quota should block requests exceeding RPM limit"""
    limits = QuotaLimits(requests_per_minute=5)
    quota = OperationalQuota(limits=limits)

    # First 5 requests should pass
    for i in range(5):
        quota.check_before_request(estimated_tokens=100)
        quota.record_request(tokens_used=100, cost_usd=0.01)

    # 6th request should fail
    with pytest.raises(QuotaExceededError, match="Request rate limit exceeded"):
        quota.check_before_request(estimated_tokens=100)

def test_quota_resets_after_window():
    """Quota should reset after time window expires"""
    limits = QuotaLimits(requests_per_minute=5)
    quota = OperationalQuota(limits=limits)

    # Fill quota
    for i in range(5):
        quota.record_request(tokens_used=100, cost_usd=0.01)

    # Wait 60s for window to expire
    time.sleep(60)

    # Should accept new requests
    quota.check_before_request(estimated_tokens=100)  # Should not raise
```

---

## Migration Notes

**Created:** 2025-11-18
**First Implementation:** PR #158 (Zero-Config Boot branch)

**Commits:**
- `a4d0a02`: feat(GAD-5): Implement Zero-Config Boot with auto-provisioning
- `5a582f1`: fix(GAD-100, GAD-501): Fix TERM crash and add config diagnostics

**Related Documentation:**
- This document created as part of Operation Glass Box (documentation sync)

---

## References

**Related GADs:**
- **GAD-509:** Circuit Breaker Protocol (resilience)
- **GAD-511:** Neural Adapter Strategy (provider abstraction)
- **GAD-500:** Runtime Engineering (self-regulating execution)
- **GAD-100:** Phoenix Configuration System

**External References:**
- [Anthropic Pricing](https://www.anthropic.com/pricing)
- [Google Gemini Pricing](https://ai.google.dev/pricing)
- [Rate Limiting Best Practices](https://cloud.google.com/architecture/rate-limiting-strategies-techniques)

---

**Last Updated:** 2025-11-19
**Next Review:** After production cost analysis
**Maintainer:** Runtime Engineering Team
