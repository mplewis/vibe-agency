# GAD-103: Schema Validation & Governance

**Status:** Phase 1 Complete (Documentation)
**Parent:** GAD-100 Configuration & Environment Management
**Created:** 2025-11-17
**Last Updated:** 2025-11-17

---

## Overview

GAD-103 defines the schema validation and governance strategy for vibe-agency state files. This ensures data integrity, prevents drift, and catches errors early.

---

## Schema Files

### Location

```
config/schemas/
├── project_manifest.schema.json      # Project state validation
├── session_handoff.schema.json       # Session context validation
├── system_integrity.schema.json      # System health validation
└── knowledge_base.schema.json        # Knowledge base validation
```

---

## Schema Standards

### JSON Schema Version

**Standard:** JSON Schema Draft 07

**Rationale:**
- Widely supported
- Mature specification
- Good validator library support (Python `jsonschema` package)

**Reference:** http://json-schema.org/draft-07/schema#

---

### Schema Template

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://vibe-agency/schemas/example.schema.json",
  "title": "Example Schema",
  "description": "Schema for example state file",
  "type": "object",
  "required": ["field1", "field2"],
  "properties": {
    "field1": {
      "type": "string",
      "description": "Description of field1",
      "examples": ["example value"]
    },
    "field2": {
      "type": "number",
      "description": "Description of field2",
      "minimum": 0,
      "maximum": 100
    }
  },
  "additionalProperties": false
}
```

---

## State File Schemas

### 1. project_manifest.schema.json

**(To be defined in Phase 2 after schema audit)**

**Purpose:** Validate project lifecycle state files

**Expected Location:** `workspaces/{project_id}/project_manifest.json`

**Proposed Structure:**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://vibe-agency/schemas/project_manifest.schema.json",
  "title": "Project Manifest Schema",
  "description": "Validates project state and lifecycle tracking",
  "type": "object",
  "required": ["metadata", "status", "artifacts"],
  "properties": {
    "metadata": {
      "type": "object",
      "required": ["projectName", "projectId", "createdAt"],
      "properties": {
        "projectName": {
          "type": "string",
          "minLength": 1,
          "description": "Human-readable project name"
        },
        "projectId": {
          "type": "string",
          "pattern": "^proj_[a-zA-Z0-9]+$",
          "description": "Unique project identifier"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp of project creation"
        },
        "owner": {
          "type": "string",
          "format": "email",
          "description": "Project owner email address"
        }
      },
      "additionalProperties": false
    },
    "status": {
      "type": "object",
      "required": ["currentPhase", "currentState"],
      "properties": {
        "currentPhase": {
          "type": "string",
          "enum": ["PLANNING", "CODING", "TESTING", "DEPLOYMENT", "MAINTENANCE"],
          "description": "Current SDLC phase"
        },
        "currentState": {
          "type": "string",
          "description": "Current sub-state within phase"
        },
        "progress": {
          "type": "number",
          "minimum": 0,
          "maximum": 100,
          "description": "Percentage completion (0-100)"
        },
        "lastUpdated": {
          "type": "string",
          "format": "date-time",
          "description": "Last status update timestamp"
        }
      },
      "additionalProperties": false
    },
    "artifacts": {
      "type": "object",
      "description": "Map of artifact names to file paths",
      "additionalProperties": {
        "type": "string",
        "pattern": "^artifacts/.*"
      }
    },
    "history": {
      "type": "array",
      "description": "Audit trail of state transitions",
      "items": {
        "type": "object",
        "required": ["timestamp", "event"],
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "event": {
            "type": "string",
            "enum": ["STATE_TRANSITION", "ARTIFACT_ADDED", "MILESTONE_REACHED"]
          },
          "from": {"type": "string"},
          "to": {"type": "string"},
          "details": {"type": "object"}
        }
      }
    }
  },
  "additionalProperties": false
}
```

**Note:** Final schema will be defined after Phase 2 schema audit reviews all existing manifests.

---

### 2. session_handoff.schema.json

**(To be defined in Phase 2)**

**Purpose:** Validate session context between Claude Code sessions

**Expected Location:** `.session_handoff.json`

**Proposed Structure:**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://vibe-agency/schemas/session_handoff.schema.json",
  "title": "Session Handoff Schema",
  "description": "Validates session context for handoffs between sessions",
  "type": "object",
  "required": ["lastSession", "context", "workspaceState"],
  "properties": {
    "lastSession": {
      "type": "object",
      "required": ["sessionId", "timestamp", "operator"],
      "properties": {
        "sessionId": {
          "type": "string",
          "pattern": "^claude/.*",
          "description": "Git branch name serving as session ID"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "operator": {
          "type": "string",
          "description": "AI operator (e.g., 'Claude Code (Sonnet 4.5)')"
        }
      }
    },
    "context": {
      "type": "object",
      "required": ["currentTask"],
      "properties": {
        "currentTask": {
          "type": "string",
          "description": "What the session is working on"
        },
        "blockers": {
          "type": "array",
          "items": {"type": "string"},
          "description": "Current blockers or issues"
        },
        "nextSteps": {
          "type": "array",
          "items": {"type": "string"},
          "description": "Planned next steps"
        }
      }
    },
    "workspaceState": {
      "type": "object",
      "properties": {
        "activeProject": {"type": "string"},
        "currentPhase": {
          "type": "string",
          "enum": ["PLANNING", "CODING", "TESTING", "DEPLOYMENT", "MAINTENANCE"]
        },
        "currentState": {"type": "string"}
      }
    }
  },
  "additionalProperties": false
}
```

---

### 3. system_integrity.schema.json

**(To be defined in Phase 2)**

**Purpose:** Validate system health manifests (GAD-005 Layer 0)

**Expected Location:** `.vibe/system_integrity_manifest.json`

**Proposed Structure:**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://vibe-agency/schemas/system_integrity.schema.json",
  "title": "System Integrity Schema",
  "description": "Validates system health check results",
  "type": "object",
  "required": ["lastCheck", "status", "checks"],
  "properties": {
    "lastCheck": {
      "type": "string",
      "format": "date-time"
    },
    "status": {
      "type": "string",
      "enum": ["HEALTHY", "DEGRADED", "UNHEALTHY"]
    },
    "checks": {
      "type": "object",
      "properties": {
        "fileStructure": {
          "type": "object",
          "required": ["status"],
          "properties": {
            "status": {
              "type": "string",
              "enum": ["PASS", "WARN", "FAIL"]
            },
            "requiredFiles": {
              "type": "array",
              "items": {"type": "string"}
            },
            "missingFiles": {
              "type": "array",
              "items": {"type": "string"}
            }
          }
        },
        "dependencies": {
          "type": "object",
          "required": ["status"],
          "properties": {
            "status": {"type": "string", "enum": ["PASS", "WARN", "FAIL"]},
            "missingPackages": {
              "type": "array",
              "items": {"type": "string"}
            }
          }
        },
        "tests": {
          "type": "object",
          "required": ["status", "totalTests", "passing", "failing"],
          "properties": {
            "status": {"type": "string", "enum": ["PASS", "WARN", "FAIL"]},
            "totalTests": {"type": "integer", "minimum": 0},
            "passing": {"type": "integer", "minimum": 0},
            "failing": {"type": "integer", "minimum": 0}
          }
        }
      }
    }
  },
  "additionalProperties": false
}
```

---

## Schema Audit Process (Phase 2)

### Step 1: Collect All State Files

```python
# tools/schema_auditor.py

def collect_state_files():
    """Collect all state files from the repository."""
    files = {
        "project_manifests": [],
        "session_handoff": [],
        "system_integrity": []
    }

    # Collect project manifests
    for manifest_path in Path("workspaces").rglob("project_manifest.json"):
        files["project_manifests"].append(manifest_path)

    # Collect session handoff
    handoff_path = Path(".session_handoff.json")
    if handoff_path.exists():
        files["session_handoff"].append(handoff_path)

    # Collect system integrity
    integrity_path = Path(".vibe/system_integrity_manifest.json")
    if integrity_path.exists():
        files["system_integrity"].append(integrity_path)

    return files
```

### Step 2: Analyze Schema Drift

```python
def analyze_schema_drift(files: List[Path]) -> Dict[str, Any]:
    """
    Analyze all files to identify schema inconsistencies.

    Returns audit report with:
    - Common keys across all files
    - Inconsistent keys (present in some, missing in others)
    - Type mismatches (same key, different types)
    - Value pattern analysis
    """
    report = {
        "total_files": len(files),
        "found_keys": set(),
        "inconsistencies": [],
        "type_mismatches": [],
        "recommendations": []
    }

    all_data = []
    for file_path in files:
        with open(file_path) as f:
            data = json.load(f)
            all_data.append((file_path, data))
            report["found_keys"].update(extract_all_keys(data))

    # Detect inconsistencies
    for key in report["found_keys"]:
        occurrences = sum(1 for _, data in all_data if key_exists(data, key))
        if occurrences < len(files):
            report["inconsistencies"].append({
                "key": key,
                "present_in": occurrences,
                "total_files": len(files),
                "percentage": (occurrences / len(files)) * 100
            })

    # Detect type mismatches
    for key in report["found_keys"]:
        types = [get_type(data, key) for _, data in all_data if key_exists(data, key)]
        if len(set(types)) > 1:
            report["type_mismatches"].append({
                "key": key,
                "types_found": list(set(types))
            })

    return report
```

### Step 3: Generate Audit Report

```markdown
# SCHEMA_AUDIT_REPORT.md (Example)

## Project Manifest Analysis

**Files Analyzed:** 5 workspaces

### Common Keys (100% present)
- metadata.projectName
- metadata.projectId
- status.currentPhase

### Inconsistent Keys
- **metadata.owner** (60% present)
  - Recommendation: Make optional
- **metadata.budget** (20% present)
  - Recommendation: Remove or make optional

### Type Mismatches
- **status.progress**
  - Found: string (40%), number (60%)
  - Recommendation: Standardize as number

### Recommendations
1. Define `projectId` pattern: `^proj_[a-zA-Z0-9]+$`
2. Make `metadata.owner` optional
3. Remove `metadata.budget` (low adoption)
4. Standardize `status.progress` as number type
```

### Step 4: Human Review

**Deliverable:** Canonical schema defined by human after reviewing audit report

**Questions for Human:**
1. Should `metadata.owner` be required or optional?
2. Should `metadata.budget` be removed or kept?
3. Should `status.progress` be string or number?
4. Are there any keys that should be added?

---

## Validation Implementation

### On Read (Phase 3)

```python
from jsonschema import validate, ValidationError

class VibeConfig:
    def get_project_manifest(self, project_id: str) -> Dict[str, Any]:
        """Load and validate project manifest."""
        manifest_path = f"workspaces/{project_id}/project_manifest.json"

        with open(manifest_path) as f:
            data = json.load(f)

        # Validate against schema
        try:
            validate(instance=data, schema=self._manifest_schema)
        except ValidationError as e:
            raise ConfigurationError(
                f"Invalid project manifest for {project_id}",
                config_path=manifest_path,
                validation_errors=[str(e)]
            )

        return data
```

### On Write (Phase 3)

```python
def save_project_manifest(project_id: str, manifest: Dict[str, Any]):
    """Validate and save project manifest."""

    # Validate before saving
    errors = validate_manifest(manifest)
    if errors:
        raise ConfigurationError(
            f"Cannot save invalid manifest",
            validation_errors=errors
        )

    # Atomic write (write to temp, then rename)
    manifest_path = f"workspaces/{project_id}/project_manifest.json"
    temp_path = f"{manifest_path}.tmp"

    with open(temp_path, "w") as f:
        json.dump(manifest, f, indent=2)

    os.rename(temp_path, manifest_path)
```

---

## Validation Error Handling

### Error Reporting

```python
class ConfigurationError(Exception):
    """Raised when schema validation fails."""

    def __init__(
        self,
        message: str,
        config_path: Optional[str] = None,
        validation_errors: Optional[List[str]] = None
    ):
        super().__init__(message)
        self.message = message
        self.config_path = config_path
        self.validation_errors = validation_errors or []

    def to_dict(self) -> Dict[str, Any]:
        """Convert to structured dict for logging."""
        return {
            "error_type": "ConfigurationError",
            "message": self.message,
            "config_path": self.config_path,
            "validation_errors": self.validation_errors
        }
```

### User-Friendly Messages

```python
def format_validation_error(error: ConfigurationError) -> str:
    """Format validation error for display."""
    lines = [
        f"❌ Configuration validation failed: {error.message}",
        ""
    ]

    if error.config_path:
        lines.append(f"File: {error.config_path}")
        lines.append("")

    if error.validation_errors:
        lines.append("Validation errors:")
        for err in error.validation_errors:
            lines.append(f"  - {err}")
        lines.append("")

    lines.append("To fix:")
    lines.append("1. Review the schema: config/schemas/")
    lines.append("2. Correct the configuration file")
    lines.append("3. Re-run validation: python tools/validation_checker.py")

    return "\n".join(lines)
```

---

## Schema Evolution

### Versioning Strategy

**Schema Files Include Version:**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://vibe-agency/schemas/project_manifest.v1.schema.json",
  "version": "1.0.0",
  ...
}
```

**State Files Reference Schema Version:**
```json
{
  "$schema": "https://vibe-agency/schemas/project_manifest.v1.schema.json",
  "metadata": {
    ...
  }
}
```

### Backward Compatibility

**Rule:** New schema versions must validate old data OR provide migration path

**Example:**
```json
// v1: required field
{
  "required": ["metadata", "status"]
}

// v2: add optional field (backward compatible)
{
  "required": ["metadata", "status"],
  "properties": {
    "newField": {"type": "string"}  // Optional (not in required)
  }
}

// v3: make old field optional (migration needed)
{
  "required": ["metadata"],  // status now optional
  "properties": {
    "status": {"type": "object"}  // Still defined, but not required
  }
}
```

---

## Testing Strategy

### Test Cases

```python
def test_valid_manifest_passes():
    """Test valid manifest passes validation."""
    manifest = {
        "metadata": {
            "projectName": "test-project",
            "projectId": "proj_abc123",
            "createdAt": "2025-11-17T10:00:00Z"
        },
        "status": {
            "currentPhase": "PLANNING",
            "currentState": "RESEARCH"
        },
        "artifacts": {}
    }

    errors = validate_manifest(manifest)
    assert errors == []

def test_missing_required_field_fails():
    """Test missing required field is caught."""
    manifest = {
        "metadata": {
            "projectName": "test-project"
            # Missing projectId!
        }
    }

    errors = validate_manifest(manifest)
    assert len(errors) > 0
    assert "projectId" in str(errors[0])

def test_invalid_enum_value_fails():
    """Test invalid enum value is caught."""
    manifest = {
        "metadata": {...},
        "status": {
            "currentPhase": "INVALID_PHASE"  # Not in enum
        }
    }

    errors = validate_manifest(manifest)
    assert len(errors) > 0

def test_schema_audit_detects_drift():
    """Test schema auditor detects inconsistencies."""
    files = ["workspace_a/manifest.json", "workspace_b/manifest.json"]
    report = analyze_schema_drift(files)

    assert "inconsistencies" in report
    assert "type_mismatches" in report
```

---

## Implementation Timeline

### Phase 1 (✅ COMPLETE)
- Documentation complete
- phoenix_config includes validation support

### Phase 2 (TODO)
- Implement schema auditor tool
- Run audit on all state files
- Generate SCHEMA_AUDIT_REPORT.md
- Human reviews and defines canonical schemas
- Create config/schemas/*.json files

### Phase 3 (TODO)
- Integrate validation into VibeConfig
- Validate on all reads/writes
- Implement error handling
- Write validation tests

---

## Best Practices

### DO:
- ✅ Validate all state files on read/write
- ✅ Provide clear error messages
- ✅ Version schemas
- ✅ Maintain backward compatibility
- ✅ Audit schemas regularly

### DON'T:
- ❌ Skip validation to "save time"
- ❌ Allow invalid data to persist
- ❌ Break backward compatibility without migration
- ❌ Use overly strict schemas (balance validation vs flexibility)

---

## Related Documents

- **GAD-100:** Configuration & Environment Management (parent)
- **GAD-101:** Multi-Source Configuration Loading
- **GAD-102:** Environment Overlays

---

**Document Version:** 1.0
**Status:** Phase 1 Complete
**Next Review:** Phase 2 Schema Audit
